{-

Description : Testing code.

-}

Task1: Geometry (15 marks) (In Geometry.hs)
-- | distance
-- >>> distance (0,0) (3,0)
-- 3
-- >>> distance (1,2) (-1,4)
-- 4

-- | vplus
-- >>> vplus (3,2) (-1,1)
-- (2,3)

-- | vminus
-- >>> vminus (3,2) (-1,1) 
-- (4,1)

-- | ptWithin
-- >>> ptWithin (2,0) ((0,0),4)
-- True
-- >>> ptWithin (0,2) ((0,0),4)
-- True
-- >>> ptWithin (4,1) ((0,0),4)
-- False
-- >>> ptWithin (1,4) ((0,0),4)
-- False

-- | extentPtsInRows
-- >>> extentPtsInRows ((0,3), 3)
-- [[(0,3),(1,3),(2,3)],[(0,4),(1,4),(2,4)],[(0,5),(1,5),(2,5)]]
-- >>> extentPtsInRows ((0, 0), 1)
-- [[(0,0)]]
-- >>> extentPtsInRows ((-1, -1), 2)
-- [[(-1,-1),(0,-1)],[(-1,0),(0,0)]]


Task2: Operation on Quad Trees (35 marks) (In QTree.hs)
-- | mapQT
-- >>> mapQT (\_ n -> n + 1) (Leaf (0,0) (Just 2))
-- Leaf (0,0) (Just 3)
-- >>> mapQT (\_ n -> n * 2) (Leaf (1,1) Nothing)
-- Leaf (1,1) Nothing
-- >>> let q1 = Leaf (0,0) (Just 1)
-- >>> let q2 = Leaf (1,0) (Just 2)
-- >>> let q3 = Leaf (0,1) (Just 3)
-- >>> let q4 = Leaf (1,1) (Just 4)
-- >>> let t' = Node ((0,0),2) Nothing
-- >>> mapQT (\(x,y) n -> show (x + y + n)) t'
-- Node ((0,0),2) Nothing
-- >>> let t = Leaf (0,0) (Just 5)
-- >>> mapQT (\_ n -> n * 2) t
-- Leaf (0,0) (Just 10)

-- | lookupQT
-- Returns 'Just a' if present, or 'Nothing' otherwise.
-- >>> let q = Leaf (0,0) (Just "1")
-- >>> lookupQT q (0,0)
-- Just "1"
-- >>> lookupQT q (1,1)
-- Nothing
-- >>> let qt = emptyQT ((-8,-8), 16)
-- >>> let qt' = insertQT (0,0) "Hello" qt
-- >>> lookupQT qt' (0,0)
-- Just "Hello"
-- >>> lookupQT qt' (1,1)
-- Nothing
-- >>> let qt'' = insertQT (0,0) "Goodbye" qt'
-- >>> lookupQT qt'' (0,0)
-- Just "Goodbye"
-- >>> lookupQT qt'' (16,16)
-- Nothing

-- | insertQT
-- >>> let t1 = Leaf (0,0) Nothing
-- >>> insertQT (0,0) "bee" t1
-- Leaf (0,0) (Just "bee")
-- >>> let t2 = emptyQT ((0,0),2)
-- >>> lookupQT t2 (0,0)
-- Nothing
-- >>> let t3 = insertQT (0,0) "bee" (emptyQT ((0,0),2))
-- >>> lookupQT t3 (0,0)
-- Just "bee"
-- >>> let t4 = insertQT (1,1) "a" $ insertQT (0,0) "b" $ emptyQT ((0,0),2)
-- >>> lookupQT t4 (0,0)
-- Just "b"
-- >>> let t5 = insertQT (1,1) "a" (emptyQT ((2,2),2)) 
-- >>> lookupQT t5 (1,1)
-- Nothing
-- >>> let t6 = insertQT (0,0) "1" $ insertQT (0,0) "2" $ emptyQT ((0,0) ,2)
-- >>> lookupQT t6 (0,0)
-- Just "1"
-- >>> let t7 = insertQT (4,4) "True" (emptyQT ((0,0),4))
-- >>> lookupQT t7 (4,4)
-- Nothing
-- >>> let t8 = insertQT (2,2) "False" (emptyQT ((2,2),2))
-- >>> lookupQT t8 (2,2)
-- Just "False"


Task 3: World and Hive Operations (15 marks)
-- | zipWithRemainders (In Hive.hs)
-- >>> zipWithRemainders [1,2,3,4] ["Hello", "world"]
-- ([(1,"Hello"),(2,"world")],[3,4],[])
-- >>> zipWithRemainders ["Hello", "world"] [1,2,3,4]
-- ([("Hello",1),("world",2)],[],[3,4])
-- >>> zipWithRemainders [] [1,2]
-- ([],[],[1,2])
-- >>> zipWithRemainders [1,2,3] []
-- ([],[1,2,3],[])

-- | growFlower (In World.hs)
-- >>> growFlower (0,0) (Flower 2 5)
-- Flower 3 5
-- >>> growFlower (1,1) (Flower 5 5)
-- Flower 5 5
-- >>> growFlower (0,0) Hive
-- Hive

-- | ageStarveAndMatureLarvae (In Hive.hs)
-- >>> ageStarveAndMatureLarvae [Larva 10 0, Larva 6 4]
-- ([],[Larva 5 3])
-- >>> ageStarveAndMatureLarvae [Larva 0 6]
-- ([Adult 5],[])
-- >>> ageStarveAndMatureLarvae [Larva 0 0]
-- ([],[])


Task 4: Fold & Filter (20 marks) (In QTree.hs)
-- | foldQT
-- >>> let q1 = Leaf (0,1) (Just "TL")
-- >>> let q2 = Leaf (1,1) (Just "TR")
-- >>> let q3 = Leaf (0,0) (Just "BL")
-- >>> let q4 = Leaf (1,0) (Just "BR")
-- >>> let tree = Node ((0,0),2) (Just (q1,q2,q3,q4))
-- >>> foldQT (\pos a acc -> (show pos ++ ":" ++ a) : acc) tree []
-- ["(0,1):TL","(1,1):TR","(0,0):BL","(1,0):BR"]
-- >>> foldQT (\pos a acc -> (pos, a) : acc) tree []
-- [((0,1),"TL"),((1,1),"TR"),((0,0),"BL"),((1,0),"BR")]
-- >>> foldQT (\_ a acc -> a : acc) (emptyQT ((0,0),2)) []
-- []
-- >>> foldQT (\_ a acc -> a : acc) (Leaf (0,0) (Just "X")) []
-- ["X"]
-- >>> foldQT (\_ a acc -> a : acc) (Leaf (1,1) (Just "2")) []
-- ["2"]
-- >>> foldQT (\_ a acc -> a : acc) (Leaf (0,0) Nothing) []
-- []
-- >>> foldQT (\_ _ acc -> acc + 1) tree 0
-- 4
-- >>> foldQT (\_ a acc -> a ++ acc) tree ""
-- "TLTRBLBR"

-- | filterQT
-- >>> let q1 = Leaf (0,1) (Just 1)
-- >>> let q2 = Leaf (1,1) (Just 2)
-- >>> let q3 = Leaf (0,0) (Just 3)
-- >>> let q4 = Leaf (1,0) (Just 4)
-- >>> let tree = Node ((0,0),2) (Just (q1,q2,q3,q4))
-- >>> filterQT even tree
-- [((1,1),2),((1,0),4)]
-- >>> filterQT odd tree
-- [((0,1),1),((0,0),3)]
-- >>> filterQT (> 2) tree
-- [((0,0),3),((1,0),4)]

In Tup4.hs
-- | map4
-- >>> map4 (+1) (1, 2, 3, 4)
-- (2,3,4,5)
-- >>> map4 (*2) (1, 2, 3, 4)
-- (2,4,6,8)

-- | fold4
-- >>> fold4 (+) (1, 2, 3, 4) 0
-- 10
-- >>> fold4 (:) ("a", "b", "c", "d") []
-- ["a","b","c","d"]

-- | update4
-- >>> update4 ((0,0),2) (0,1) (++ "!") ("TL", "TR", "BL", "BR")
-- ("TL!","TR","BL","BR")
-- >>> update4 ((0,0),2) (1,1) (++ "!") ("TL", "TR", "BL", "BR")
-- ("TL","TR!","BL","BR")
-- >>> update4 ((1,1),4) (1,1) (*2) (1,2,3,4)
-- (1,2,6,4)

-- | select4
-- >>> select4 ((0,0),2) (0,1) ("TL", "TR", "BL", "BR")
-- "TL"
-- >>> select4 ((0,0),2) (1,1) ("TL", "TR", "BL", "BR")
-- "TR"
-- >>> select4 ((0,0),2) (0,0) ("TL", "TR", "BL", "BR")
-- "BL"
-- >>> select4 ((0,0),2) (1,0) ("TL", "TR", "BL", "BR")
-- "BR"
